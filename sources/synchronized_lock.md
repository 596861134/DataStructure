### Synchronized 与 Lock区别

线程总共有5大状态，通过上面第二个知识点的介绍，理解起来就简单了。

新建状态：新建线程对象，并没有调用start()方法之前

就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。

运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态

阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态

死亡状态：线程执行结束


类别	synchronized	Lock

1. 存在层次	

    - synchronized是Java的关键字，在jvm层面上  
    - Lock是一个类是一个API接口
    
2. 锁的释放
    - synchronized以获取锁的线程执行完同步代码、释放锁 ，线程执行发生异常，jvm会让线程释放锁
    - Lock 必须在finally中必须释放锁，不然容易造成线程死锁
 
3. 锁状态
    - synchronized 无法判断锁状态
    - Lock 可以通过tryLock判断锁状态
    
4. 性能	
    - synchronized少量同步	
    - Lock大量同步
    
5. 锁类型	
    - synchronized可重入 不可中断 非公平	
    - Lock可重入 可判断 可公平（两者皆可）
    


